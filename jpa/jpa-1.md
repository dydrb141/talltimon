# JPA 기본

### Jpa가 머냐

* 자바진영 ORM 표준 기술
* JPA는 자바 ORM기술에 대한 API 표준 명세
* 하이버네이트는 JPA를 구현한 프레임워크

### ORM은 머냐

* Oriented Relational Mapping 의 약자로써 객체와 관계형 데이터 베이스의 데이터를 자동으로 매핑 해주는 기술

즉 JPA는 자바진영 ORM기술에 대한 API를 명세 한거고 ORM은 객체와 관계형 데이터베이스를 자동으로 매핑해주는 기술을 말한다. JPA 명세를 구현한게 여러가지 있지만 그중 하이버네이트를 많이 사용하고 스프링에서는 하이버네이트를 사용하기 위해서 spring-data-jpa를 제공해준다.

### JPA를 왜 사용하나?\(장점 ORM장점과 동일함\)

**장점**

* 객체지향적 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있다. \(sql을 작성하지 않아도 된다\) 
* 생산성과 유지보수가 좋아짐 \( 객체 재사용 가능\)
* 테스트를 작성하기에 편리해짐
* 코드를 수정하지 않고 데이터 베이스를 손쉽게 변경 \(dbms종속성이 줄어듬, 벤더 독립성 \(Dialect\)\)

**단점**

* ORM만으로는 서비스를 구현하기가 어렵다
* 복잡성이 커질경우 난이도도 올라갈 수 있음
* 프로시저가 많으면 적용하기 어려움 

### 영속성 컨텍스트란

* 엔티티를 영구 저장하는 환경
* 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티트를 보관하고 관리함

### 엔티티 생명주기

4가지 상태 생명주기가 존재

1. 비영속\(new/transient\) : 영속성 컨텍스트와 전혀 관계가 없는 상태
2. 영속 : 영속성 컨텍스트에 저장된 상태
3. 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태 \(em.close\(\), em.clear\(\), em.detach\(\)\) 
4. 삭제 : 삭제된 상태  \(em.remove\)

### 엔티티 매니저 팩토리와 엔티티 매니저

엔티티 매니저 팩토리는 만드는 비용이 크기 때문에 공유해서 사용 엔티티 매니저는 팩토리는 스레드 세이프 하지만 엔티티 매니저는 스레드세이프 하지 않다.

```text
EntityManagerFactory emf = Persistence.createEntityManagerFactory("jap");
EntityManager em = emf.createEntityManager();
```

### 영속성 컨텍스트 특징

영속성 컨텍스트와 식별자 값 - 영속 상태는 식별자 값이 반드시 있어야 함. 영속성 컨텍스트와 데이터베이스 저장 - 플러쉬 영속성 컨텍스트 장점 1. 1차 캐시 - 영속성 컨텍스트에 있다면 키값으로 캐시를 태울수 있음 없으면 db조회해서 영속성 컨텍스트에 보관 2. 동일성 보장 - 1차 캐시에서 조회하므로 동일성을 보장 3. 트랜잭션을 지원하는 쓰기 지연 - 트랜잭션을 커밋하기 직전까지 insert sql을 쓰기지연 저장소에 모아두고 커밋할때 보냄 4. 변경 감지 - 스냅샷을 비교해서 변경된 데이터가 있으면 쓰기지연 저장소의 sql을 db에 보내고 커밋 5. 지연 로딩

### 플러시

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

플러시 를 실행했을때 일어나는 일

1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교

   수정 쿼리를 만들어서 쓰기 지연 저장소에 등록

2. 쓰기지연 저장소의 쿼리를 db에 저장

   플러시 방법 3가지

3. em.flush\(\)
4. 트랜잭션 커밋 시 플러시 자동 호출
5. JPQL 쿼리 실행시 자동 호출

#### merge

준영속 상태의 엔티티를 영속 상태로 변

## 엔티티 매핑

### Entity

* 테이블과 매핑할 클래스는 필수 어노테이션

  주의사항

  * 기본 생성자 필수 
  * final 클래스, enum, interface, inner 클래스 사용 불가
  * 저장할 필드에 final 사용 불가

  **Table**

* 엔티티와 매핑할 테이블 지정, 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용

  **기본키 매핑**

  직접 할당 : @Id만 해주고 소스에서 직접 키를 생성해줌 자동 생성 : 1. IDENTITY: 데이터 베이스 기본키 사용\(MYSQL\), 먼저 엔티티를 데이터베이스에 저장후 식별자를 조회해서 엔티티의 식별자에 할당

  1. SEQUENCE: 데이터베이스 시퀀스 사용\(오라클\), em.persist\(\)를 호출할 때 데이터 베이스 시퀀스를 조회하고 식별자를 할당후 엔티티 컨텍스트에 저장 트랜잭션을 커밋해서 플러시가 일어나면 데이터베이스에 저장
  2. TABLE: 키 생성 테이블 사용 , 키 생성 전용 테이블을 하나 만들고 따로 관리할때 사용
