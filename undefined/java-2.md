# Java Basic 2

## 프로세스와 스레드

**프로세스** :

* 컴퓨터에서 연속적으로 실행되는 컴퓨터 프로그램
* 메모리에 올라와 실행되고 있는 프로그램 인스턴스
* 운영체제로부터 시스템 자원을 할당받는 작업의 단위

**스레드** :

* 프로세스 내에서 실행되는 여러 흐름의 단위
* 스레드는 프로세스 내에서 각각 스택만 할당 받고 code, data, heap영역은 공유

**자바 스레드란**:

* 일반 스레드와 거의 차이가 없으며 jvm 운영체제의 역할을 한다.
* 자바는 프로세스가. 존재하지 않고 스레드만 존재
* 스레드 스케쥴링은 전적으로 jvm에 의해서 의루어진다

## 멀티 프로세스와 멀티 스레드 차이

**멀티 프로세싱**

* 하나의 응용프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는것

**장점**

* 여러 개의 자식 프로세스중 하나에 문제가 발생 하더라도 다른 자식들에게 영향을 주지 않음

**단점**

컨텍스트 스위칭 오버헤드

* 컨텍스트 스위칭 과정에서 캐쉬 메머리 초기화 등 무거운 작업이 진행 되고 많은 시간이 듬
  * 각각 독립된 메모리를 할당 받았기 때문에 각각의 프로세스들은 변수를 공유 할 수 없다.

컨텍스트 스위칭이란? CPU에서 여러 프로세스들이 돌아가면서 작업을 처리하는 과정

**멀티 스레드**

* 하나의 응용 프로그램을 여러개의 스레드로 구성
* 각 스레드로 하나의 작업을 처리
* 웹 서버는 대표적인 멀티 스레드 응용 프로그램

**장점**

* 시스템 자원 소모 감소
* 시스템 처리량 증가
* 간단한 통신 방법으로 인한 프로그램 응답시간 단축

**단점**

* 디버깅이 어려움
* 단일 프로세스인 경우 효과를 기대하기 어려움
* 자원 공유 문제\(동기화 문제\)
* 하나의 스레드가 문제가 발생하면 전체 프로세스가 영향 받음

### 동시성 과 병렬성

**동시성** : 하나의 코어에서 멀티 스레드가 번갈아 가며 실행 \(번갈아 가면서 실행하는게 빨라서 동시 작업으로 보임\)

**병렬성** : 멀티 코어에서 개별 스레드를 동시에 실행

### 스레드 스케줄링

* 스레드를 어떤 순서에 의해 동시성으로 실행할 것인가를 결정

**스레드 스케줄링 방식**

* 우선순위 방식 : 우선순위가 높은 스레드가 실행 상태를 더 많이 가져감 \(setPriority\(\)\) 10이가장 높음
* 라운드 로빈 방식 : 시간 할당량\(time slice\)를 정해서 하나의 스레드를 정해진 시간만큼 실행하고 다시 다른 스레드를 실행하는 방식

  즉 정해진 시간에만 실행

**임계영역** : 단 하나의 스레드만 실행할 수 있는 코드 영역 자바에서는 syncronized 메소드와 동기화 블록을 제공하여 임계영역을 제공할 수 있다.

**스레드 상태**

NEW \(객체생성\): 스레드 객체 생성 아직 start\(\)를 호출 안함

RUNNABLE\(실행대기\): 실행 상태로 언제든 갈 수 있는 상태

RUNNING \(실행\): run메소드를 실행하는 상태

**일시정지**

* WATING : 다른 스레드가 통지할 때 까지 기다리는 상태
* TIME\_WATING: 주어진 시간 동안 기다리는 상태
* BLOCKED : 사용하고자 하는 객체의 락이 풀릴때 까지 기다리는 상태

TERMINATED \(종료\) : 실행을 마친 상태

**스레드풀**

* 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 큐에 들어오는 작업들을 하나씩 스레드가 맡아서 처리

Java.util.concurrent 패키지에서 ExecutorService인터페이스 와 Executors클래 제공

**스레드풀 생성 및 종료**

* ExecutorService 구현한 Executors클래스는 다음 두 가지 메소소드중 하나를 이용해 간편하게 생성 가능
* newCachedThreadPool\(\) - 처리할 작업 스레드가 많아지면 스레드를 증가, 쉬는 스레드가 있다면 종료
* newFIxedThreadPool\(int nThread\)  - 주어진 스레드만큼 생성하고 수를 유지, 스레드가 종료 되면 다시 생성해서 갯수 맞춤
* NewSingleThreadExecutor - 스레드를 단 하나만 생성
* ExecutorService executorService = Executors.newFixedThreadPool\(10\);
* **스레드 종료**
* shutdown - 현재 처리하는 작업 뿐 아니라 작업 큐에 대기 하고 있는 모든 작업을 처리하고 종료
  * List&lt;Runnable&gt; shutdownNow\(\) - 현재 작업중인 스레드를 intterupt 작업 중지 시도후 스레드풀 종료
  * awaitTermination\(long timeout, TimeUint unit\) - shutdown\(\)메소드 호출이후 timout시간내에 완료하면 true 완료 못하면 false

**Submit과 execute차이**

1. execute는 작업 처리 결과를 받지 못하고 submit은 작업 처리 결과를 받을수 있도록 Future를 리턴
2. execute는 작업 처리 도중 예외가 발생하면 스레드가 종료 스레드 풀에서 제거 되지만 submitd은 예외가 발생하면 스레드가 종료되지 않고 다음 작업을 위해 재사용
3. 오버헤드를 줄이기 위해 submit을 사용하는게 좋음

작업 완료 순으로 통보

* 스레드풀에서 작업 처리가 완료된 것만 통보 받는 방법 CompletionService를 이용

**ComplitionService**

* poll : 완료된 작업의 Future를 가져옴, 완료된 작업이 없으면 Null 리턴
* take : 완료된 작업의 Future를 가져옴, 완료된 작업이 없다면 있을때 까지 블로킹
* submit

## 제네릭

### 제네릭의 이점

* 컴파일시 강한 타입 체크 : 컴파일시 미리 타입 체크
* 타입 변환 제거 : 타입 변환은 성능에 악영향
* 런타임 마킹용으로 사용

공변성 : 타입 T를 확장한 타입에 대해서 허용

반공변성 : 타입 T의 상위 타입에 대해서 만 허용

무공변성:타입 T만 허용

**와일드카드 타입.**

&lt;?&gt; : Unbounded Wildcards, 모튼 클래스나 인터페이스 타입이 올수 있음

&lt;? extends 상위타입&gt;: Upper Bounded Wildcards 상위 타입이나 하위 타입만 올수 있다.

&lt;? extends 하위타입&gt; : Lower Bounded wildcards 하위 타입이나 상위 타입만 올 수 있다.

**람다식이란**?

실별자 없이 실행 가능한 함수

함수를 따로 만들지 않고 코드 한줄에 함수를 써서 그걸 호출 하는 방식

**장점**

1. 코드를 간결하게 만듬, 가독성 향상
2. 함수를 만드는 과정없이 한번에 처리 가능하기 때문에 코딩 시간이 줄어듬
3. 병렬 프로그래밍이 용이함

**단점**

1. 람다를 사용하면서 만든 익명함수는 재상용 불가
2. 디버깅이 까다로움
3. 람다를 남발하면 지저분해질수 있음

### 타켓 타입과 함수형 인터페이스

**타겟타입** : 대입될 인터페이스 종류에 따라 작성 방법이 달라지기 때문에 람다식이 대입될 인터페이스를 람다식의 타겟 타입이라함

**함수형 인터페이스** : @FuntionalInterface를 붙여줌 없어도 하나의 추상 메소드만 있다면 함수형 인터페이스

### 표준 API의 함수형 인터페이스

java.utils.function캐피지의 함수적 인터페이스

**Consumer**

* 매개값은 있고 리턴값은 없음, accept\(\)메소드로 매개값을 소비한다.
  * BiConsumer : void accpet\(T t, U u\) 객체 T와 U를 받아 소비\)

Consumer&lt;String&gt; consumer = t -&gt; { t를 소비};

Suppler - 매가값은 없고 리턴 값은 있음

Supplier&lt;String&gt; supplier = \(\) -&gt; {return “문자열”;}

Function - 매개값도 있고 리턴 값도 있음, 주로 매개값을 리턴으로 매핑\(타입변환\)

-BiFunction&lt;T, U, R&gt; - R apply\(T t, U u\) : 객체 T와 U를 객체 R로 매핑

Operator - 매개값도 있고 리턴 값도 있음 , 주로 매개값을 연산 하고 결과를 리턴

* Funtion과 비슷하지만 타입 변환 역할보다 매개값을 이용해 연산을 한다음 동일한 타입으로 리턴값을 제공
* BinaryOperator&lt;T&gt;: BiFunction&lt;T, U ,R&gt;의 하위 인터페이스 T와 U를 연산후 R리턴
* UnaryOperator&lt;T&gt; Function&lt;T, T&gt; 하위 인터페이스 T를 연산후 T를 리턴

Predicate. - 매개값은 있고 리턴 타입은 boolean 매개값을 조사해서 true/false

* test

## 컬렉션 프레임웍크

**배열의 장점**

* 쉽게 생성 할 수 있고 쉽게 사용 가능 하다.

**단점**

* 저장 가능한 수가 배열을 생성할때 결정 되어 불특정 다수의 객체를 저장하기에는 문제가 있음
* 객체를 삭제 했을대 해당 인덱스가 비게 되는 문제가 있음
* 어디가 비었는지 확인하는 코드가 필요

자바에서는 이런 문제점을 해결하고자 java.util.collection을 제공

### Collection

* List : 순서를 유지하고 저장, 중복 저장 가능

### ArrayList

```text
 장점. :   인덱스를 가지고 있어 조회가 빠름

 단점  : 저장 용량을 초과하면 자동으로 저장 용량이 늘어난다. 

           중간에 삭제를 하면 한칸씩 앞땡겨짐

           중간에 삽입하면 리스트의 모든 값을 한칸씩 뒤로 밈

           그래서 추가 삭제에 성능이 안좋다. 
```

### LinkedList

* 인접 참조 링크를 크해서 체인처럼 관리

  장점 : 삭제 추가가 빠르다.

* 삭제 : 삭제 대상의 이전 요소와 다음 요소를 참조 하도록 하면 됨으로  단 한번의 참조만 변경하면 삭제가 이루어짐
* 추가. : 추가 하고자 하는 요소의 이전 요소를 새로운 요소에 참조로 변경해주고 새로운 요소가 다음 요소를 참조 하도록 변경 하면 끝

  단점 : 데이터를 조회하려면 리스트를. 모두 순회하면서 찾아야 되기 때문에 느리다.

  ```text
           다음 요소에 대한 접근은 쉽지만 이전 요소에 대해 접근이 어렵다 \(단방향인 경우 \)
  ```

### 더블 링크드 리스트

```text
     링크드 리스트에 참조를 하나 더 추가 하여 이전 참조도 가능 하도록
```

**이중 원형 연결리스트** \( 더블 서큘러 링크드 리스트\) : 더블 연결 리스트에서 첫 뻔째 요소와 마지막 요소를 연결 시킴

* ArrayList와 동일한 내부구조를 가지고 있지만 동기화된 메소드를 구성하고 있다.

### 이진 트리 \(Binary Tree\)

* 노드의 최대 차수가 2인 트리

### 편향 이진 트리

* 노드들이 한쪽으로 편향되어 생성됨

  문제점 :

* 탐색속도 저하 : 한쪽으로 편향되게 되면 아무래도 모든 노드를 탐색해야되기 때문에 속도가 저하된다.
* 공간낭비

### 포화. 이진 트리

* 마지막 레벨까지 모든 노드가 있는 이진 트리

### 완전 이진 트리

* 루트 노드를 1이라고 하고 그외의 모든 노드가 왼쪽에서 오른쪽까지 꽉 차서 노드 수가 n &lt;=\(2 k+1 - 1\) 조건을 만족하면 완전 이진 트리이다.

### 이진 탐색 트리

* 이진 트리에서 조건이 추가됨
  * 부모 노드를 위치 시키고 부모 보다 작은값은 왼쪽 부모 보다 큰 값은 오른쪽에 위치 시킴
  * 검색을 쉽게 할 수 있는 이유는 그룹핑이 가능하기 때문\( ex 루트가 6이고 6 미만인 값을 찾는다면 왼쪽만 찾으면 되고 큰값을 찾는다면 오른쪽 기준으로 찾으면 됨\)

### 이진트리 순회

중위 레프트 루트 라이트 \(형보다 동생을 더 이뻐한다\)

전위 루트 레프트 라이트 \(자식보단 부모가 우선이다\)

후위 레프트 라이트 루트 \(부모는 모든 자식들을 챙겨야 하기 때문에 자식들을 모두 방문한다음 나를 챙긴다\)

* Set : 순서를 유지 하지 않고 저장, 중복 저장 안됨

### - HashSet

### - TreeSet

* 이진트리를 기반으로 한 set컬렉션
* treeSet에 객체를 저장하면 자동 정렬 됨
  * 부모값과 비교해서 낮은 것은 왼쪽 자식 노드에, 높은것은 오른쪽 자식 노드에 저장

### - Queue

* LinkedList
* PriorityQueue

Map : 키와 밸류 쌍으로 저장, 키는 중복 저장 안됨

* HashMap
* LinkedHashMap
  * TreeMap
  * 이진 트리를 기반으로 한 Map 컬렉션
  * 키와 값이 저장된 Map.Entry를 저장
  * 부모 키값과 비교해서 키값이 낮은 것은 왼쪽 큰것은 오른쪽에 Map.Entry를 저장
* Properties

Comparable과 Comparator 차이

Comparable : compareT\(T o\)

주어긴 객체와 값이 같으면 0, 적으면 음수, 크면 양수

사용하는 클래스에 임플받고 오버라이딩 해서 구현

Comparator : compare\(T t1, T t2\) :” t1과 t2가 동등하면 0 앞에 오게 하려면 음수 뒤에 오게 하려면 양수

사용하는 클래스에 구현이 안되어 있어도 직접 Comparator를 구현한 구현체를 new TreeSet&lt;Fruit&gt;\(new DecendingComaprator\(\)\); 같이 넘겨주면 정렬 됨

### 동기화 컬렉션

* synchroinzelIst\(List&lt;T&gt; list\)
* synchronizeMap\(Map&lt;K, V m\)
* synchronizeSet\(Set&lt;T&gt; s\)
  * 각 메소드 마다 내부적으로 synchronized처리 되어있음
  * 각 메소드가 synchronyzed되어 있다고 하더라도 동기화 문제가 발생할 수있음

```text
List<String> list = Collections.synchronizedList(new ArrayList());
  ExecutorService execute = Executors.newFIxedThreadPool(2);
   For (int I = 0; I < 2; I ++ ) {
    execute.execute(() -> {
   while(true) {
     try {
       list.clear();
       list.add(“88”);
       list.remove(0);
     }
   }
 });
}
```

a스레드가 remove\(\) 하는 순간에 b스레드가 CLear하면 익셉션 발생

```text
syncronized(list) {
 list.clear();
 list.add(“88”);
 list.remove(0);
}
```

## 동기화를 회피할 수 있는 컬렉션

**- CopyOnWriterArrayList**

* read는 동기화 문제가 없기 때문에 놔두고 변경이 일어날 경우 객체를 clone해서 다룸
* 읽기가 많이 일어나느 곳에서 사용하기 좋음

  **- BlockingQueue**

  * 생산자 소비자 패턴에서 활용되는 큐로 많이 사용 됨
  * 큐를 사용해 넣고 뺄때 블로킹 하고 데이터가 들어가면 wait하고 있는 다른 스레드를 깨워서 넣음
  * 내부적으로는 ReentrantLock을 사용하고 있으며 전체 용량이 꽉차 있으면 스레드를 대기 시킴
  * 마찮가지로 take할때도 락을 걸고 count가 0이면 대기시킴
  * final 구문에 unlock

  **- ConcurrentHasMap**

  * key value null값 허용하지 않음
  * 내부적으로 여러개의 세그먼트를 두고 각 세그먼트마다 별도의 락을 가지고 있음
  * 때문에 여러 스레드 에서 동시 삽입 참조하더라도 그 데이터가 다른 세그먼트에 위치하면 락을 얻기 위해 경쟁하지 않음
  * 레코드 락과 유사한 방식이라 보면됨
  * 이런 방식을 lock striping 방식이라함
  * 기본적으로 16개로 나눔 너무 적게 나누면 관리 비용이 커짐

### 스트림이 머냐

* 자바 8에서 추가된 기능
* 함수형 인터페이스인 람다를 활용
* 멀티 스레드 코드를 작성하지 않고 데이터를 병렬로 처리 가능

중간처리

필터링

* distinct\(\) : 중복 제거
  * filter\(\) : 매개값으로 주어지는 Predicate가 true를 리턴하는 요소만 필터링

매핑

* flatMap\(\) : 기존 요소를 대체하는 새로운 요소의 스트림을 만듬

  Ex \) String\[\]\[\] data = new String\[\]\[\];

Stream&lt;String\[\]&gt; temp = Arrays.stream\(data\);

temp.flatMap\(x -&gt; Arrays.stream\(x\)\).forEach\(System.out::println\);

{ {'a','b'}, {'c','d'} } -&gt; flatMap -&gt; {'a','b','c','d''}

* map\(\) : 단일 스티림 원소를 매핑시킨후 매핑시킨값을 다시 스트림으로 반환
* asStream\(\) :asDoubleStream은 int나 long을 double로 변환
* box\(\) : int, long, double 요소를 와퍼 클래스로 박싱해서 Stream 생성

최종 집계

매칭

allMatch\(\) : 스트림의 요소가 Pedicate조건을 모두 만족하는지

anyMath\(\) : 스트림의 요소가 Predcate조건을 하나라도 만족하는지

noneMath\(\) : 스트림의 요소가 Predicate조건을 모 두 만족하지 않는지

동시성과 병렬성

동시성 :멀티 작업을 위해 멀티 스레드가 번갈아가며 실행

병렬성 : 멀티 작업을 위해 멀티 코어를 이용해 동시에 실행

포크조인 프레임워크

* 병렬 스트림을 이용하면 런타임시 포크조인 프레임워크가 동작
* 포크 단계에서 전테 데이터를 서브 데이터로 분리
* 서브 데이터를 멀티코어에서 병렬로 처리
* 조인 단계에서 결합하여 최종 결과 산출
* ForkjoinPool 제공

IO와 NIO차이

입출력 스트림 , 채널

버퍼 방식 넌버퍼, 버퍼

비동기 지원안함, 지원

블로킹 /넌블러킹 블로킹 방식만 지원, 블로킹/넌블로킹 모두 지원

Volatile

* 컴퓨터의 메인 메모리로 부터 읽히고 쓰기작업은 메인 메모리로 직접 이루어진다 \(cpu가 쓰이지 않음\)
* 스레드에 대한 변수 변경의 가시성을 보장
* none-volatile 변수는 cpu캐시를 이용한다.
* 가시성 문제 : 쓰레드가 변경한 값이 메인 메모리에 저장되지 않아서 다른 쓰레드가 볼수 없는 상황
* 가시성은 보장하지만 원자성은 보장하지 않는다
* 한 스레드에서 공유 변수를 읽기/쓰기 작업을 하고 다른 쓰레드에서는 읽기 작업만 할때 volatile이 유용함
* 원자성을 보장할라면 AtomicLong, AtomicReference를 사용 해야 함.

Atomic

* 원자성을 보장함
* CAS\(compare-and-swap\)기반으로 되어있음
* CAS란 : 주어진 값을 비교하여 같으면 새로운 값으로 대체

직렬화

* 자바 내부에서 사용하던 객체 또는 데이터를 바이트 형테로 변환하는 기술, 반대의 개념을 역직렬화

직렬화 조건

* 자바 기본 타입과 [java.io](http://java.io).Serializable 인터페이스를 상속받은 객체

직렬화 방법

[java.io](http://java.io).ObjectOuputStream 사용

역직렬화 조건

* 직렬화 대상 객체는 동일한 serialVirsionUID를 가지고 있어야 함.
* 객체 대상이 같은 패키지 안에 있어야 함

